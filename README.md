# eig

–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ 
–∏—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–º –º–µ—Ç–æ–¥–æ–≤.

–ü—Ä–∏—á–∏–Ω–∞: –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ —á–∞—Å—Ç–æ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫–æ–ª–µ–±–∞–Ω–∏–π –∏–ª–∏ —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ 
–º–µ—Ç–æ–¥–æ–º –∫–æ–Ω–µ—á–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∏–º–µ—Ç—å –ª–∏—à—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–æ–±—Å–≤–µ–Ω–Ω—ã—Ö 
–∑–Ω–∞—á–µ–Ω–∏–π —á—Ç–æ –∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç—Å—è –∏—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏, –∞ –Ω–µ –≤—Å–µ—Ö 
–∫–∞–∫ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –ø—Ä—è–º—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏.

–û–±—â–∏–π –≤–∏–¥ —É—Ä–∞–≤–Ω–µ–Ω–∏—è:
```
A ¬∑ x = Œª ¬∑ B ¬∑ x, 
–≥–¥–µ:
	A,B - —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã
	x   - —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä
	Œª   - —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
```

–ê–ª–≥–æ—Ä–∏—Ç–º –±—É–¥—É –ø–∏—Å–∞—Ç—å –Ω–∞ —è–∑—ã–∫–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è `Golang` –≤ —Å–≤—è–∑–∏ —Å —Ç–µ–º,
—á—Ç–æ —è–∑—ã–∫ —É–∂–µ –∑–Ω–∞–∫–æ–º –∏ –æ–±–ª–∞–¥–∞–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ä–∏–µ–º –¥–ª—è 
–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è.

## –°—Ç–µ–ø–µ–Ω–Ω–æ–π –º–µ—Ç–æ–¥(power method)

–ù–∞—á–Ω–µ–º —Å —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—è —Å—Ç–µ–ø–µ–Ω–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞, –∫–∞–∫ —Å –Ω–∞–∏–±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–≥–æ —Å —Ç–æ—á–∫–∏
–∑—Ä–µ–Ω–∏—è –ø—Å–µ–≤–¥–æ–∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –Ω–∏–∂–µ:

```
–í—ã–±–∏—Ä–∞–µ–º –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π –≤–µ–∫—Ç–æ—Ä x(0)
for k = 1,2,...		(while )
	z(k) = A ¬∑ x(k-1)
	x(k) = z(k) / || z(k) ||
	if ||q(k-1)-q(k-2)|| < ùõÜ then break
end

Œª = (Ax , x) / (x , x)

```

–ò—Å–ø–æ–ª—å–∑—É–µ–º–∞—è –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞:
* http://ergodic.ugr.es/cphys/LECCIONES/FORTRAN/power_method.pdf
* http://www.cs.huji.ac.il/~csip/tirgul2.pdf

–°—Ä–∞–∑—É —Å—Ç–æ–∏—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–∞–Ω–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—Ä–∞–∂–∞–µ—Ç—Å—è –≤ 
` | Œª1 | > | Œªi | `, —Ç–æ –µ—Å—Ç—å –ø–µ—Ä–≤–æ–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞—Ç—å, 
—á—Ç–æ –Ω–µ –≤—Å–µ–≥–¥–∞ –≤—ã–ø–æ–ª–Ω–∏–º–æ, –∫ –ø—Ä–∏–º–µ—Ä—É:

```
A = 
[1  0]
[0 -1]

Œª1 = 1
Œª2 = -1
```

```
A = 
[ 2 0 0 ]
[ 0 2 0 ]
[ 0 0 1 ]

Œª1 = 2
Œª2 = 2
Œª3 = 1
```

–ù–æ –∑–Ω–∞—è —ç—Ç–æ –Ω–∞–¥–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞–∫ –≤–µ–¥—ë—Ç —Å–µ–±—è –∞–ª–≥–æ—Ä–∏—Ç–º.

–ù–∞—á–Ω–µ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—à–µ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Å –∑–∞—Ä–∞–Ω–µ–µ –∑–∞–¥–∞–Ω–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
–∑–∞–¥–∞–≤–∞–µ–º—ã—Ö –Ω–∞ —Ç–µ–∫—É—â–∏–π —ç—Ç–∞–ø, –∞ –∏–º–µ–Ω–Ω–æ:
* –∞–ª–≥–æ—Ä–∏—Ç–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞–±–æ—Ç–∞—é—â–∏–º
* –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –º–∞—Ç—Ä–∏—Ü—ã 3—Ö3 –∏ 2—Ö2
* —Ç–µ—Å—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –∑–∞–Ω–∏–º–∞—Ç—å –±–æ–ª–µ–µ 1 —Å–µ–∫—É–Ω–¥—ã
* –≤–æ–ø—Ä–æ—Å—ã –æ–± –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Ä–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏–≤–∞–Ω–∏–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è
* –∫–∞–∂–¥—ã–π —ç—Ç–∞–ø —Å–æ —Å–≤–æ–∏–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω—ã–º –∫–æ–¥–æ–º —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ –æ—Ç –¥—Ä—É–≥–∏—Ö - —Ä–∞–∑–±–∏—Ç–æ –Ω–∞ –ø–∞–ø–∫–∏
* —Ä–∞—Å—á–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–≥–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–π

–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ `step00`:
```golang
package main

import (
	"fmt"
	"math"
	"math/rand"
	"time"
)

// —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
type eigen struct {
	// —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
	ùú¶ float64

	// —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä
	ùëø []float64
}

func pm(A [][]float64) (e eigen, err error) {
	n := len(A)
	x := make([]float64, n)
	xLast := make([]float64, n)

	rand.Seed(time.Now().UnixNano())

	// –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º –≤–µ–∫—Ç–æ—Ä–æ–º
	for i := range x {
		x[i] = rand.Float64() // [0.0, 1)
	}

	// —Ç–æ—á–Ω–æ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
	ùõÜ := 0.001

	for iter := 0; ; iter++ {
		// z(k) = A ¬∑ x(k-1)
		z := make([]float64, n)
		for row := 0; row < n; row++ {
			for col := 0; col < n; col++ {
				z[row] += A[row][col] * x[col]
			}
		}

		// x(k) = z(k) / || z(k) ||
		{
			max := z[0]
			for i := range z {
				if math.Abs(z[i]) > math.Abs(max) {
					max = z[i]
				}
			}
			for i := range x {
				x[i] = z[i] / max
			}
		}

		// ||x(k-1)-x(k-2)|| > ùõÜ
		if iter > 0 {
			var max float64
			for i := range x {
				e := math.Abs(x[i] - xLast[i])
				if e > max {
					max = e
				}
			}
			if max < ùõÜ {
				// –≤—ã—Ö–æ–¥–∏–º –∏–∑ –∏—Ç–µ—Ä–∞—Ü–∏–π
				break
			}
		}

		// —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π
		if iter > 10000 {
			err = fmt.Errorf("Iteration limit")
			return
		}

		// –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
		fmt.Printf("iter: %2d\tx = %v\n", iter, x)
		copy(xLast, x)
	}

	// Œª = (Ax , x) / (x , x)
	e.ùëø = x

	Ax := make([]float64, n)
	for row := 0; row < n; row++ {
		for col := 0; col < n; col++ {
			Ax[row] += A[row][col] * x[col]
		}
	}
	var Axx float64
	for i := range x {
		Axx += Ax[i] * x[i]
	}
	var xx float64
	for i := range x {
		xx += x[i] * x[i]
	}

	e.ùú¶ = Axx / xx

	return
}
```

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –±—É–¥–µ—Ç —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:

```
package main

import "testing"

func Test(t *testing.T) {
	t.Run("1", func(t *testing.T) {
		e, err := pm([][]float64{
			{2, -12},
			{1, -5},
		})
		if err != nil {
			t.Fatal(err)
		}
		t.Log(e)
	})
}
```
